---
title: Indexes
categories: editing
order: 10
---

# Indexes
{:.no_toc}

* toc
{:toc}

## Introduction

An index (the long list with the page numbers at the end of a book) is an important part of many non-fiction print books (many ebooks don't include indexes, and instead rely on ebook app's search function). Traditionally, indexes are created by professional indexers, who read the final page proofs and compile a list of entries and page numbers manually. They do not only add words to the index, but entire concepts. For instance, a good indexer will include an entry for 'democracy' in an index if the concept is discussed, even if the word 'democracy' is never used. This is why good indexes cannot be generated by computers.

In this workflow, the challenge is in managing page numbers: our workflow allows you to reflow the content into new formats, so page numbers are never quite fixed. Well, you might decide that a particular format's pages are fixed enough for allow for manual page numbers in an index, but then you cannot reuse that index in another format.

So here we'll describe how to create an index where the page numbers are dynamic. That is, the index is a list of concepts that point to a particular point in the book. The page numbers in the index (and clickable hyperlinks in an ebook version) are then generated on the fly whenever you output to PDF. This also means you can index early in the production process, such as during editing, rather than waiting for pages to be finalised.

> Note: Be careful not to confuse an index in a book with the `index` page of a website. When talking about websites, the `index` page is the home page of a directory. So never give your reference index the file name `index` (e.g. `index.md` or `index.html`). To avoid confusion, in our code we refer to the `reference-index` when we mean a book's index. 

To create an index you have to do two things:

1. In the text, tag the words that their index entries will point to. 
2. Create an index document with a list of entries.

## Creating the index [this method still being developed]

### How to tag indexed concepts

We use HTML comments to note where indexed concepts or phrases appear in our text. The HTML comment must start with `index:`. An HTML comment between block elements (e.g. between paragraphs, lists, or blockquotes) can contain any number of index entries that appear in the element that follows the comment. E.g.:

``` md
<!--index:
Holmes, Sherlock
Adler, Irene
-->

To Sherlock Holmes she is always THE woman. I have seldom heard him mention her under any other name.
```

In the final index, the link in web, app and epub formats, and the page number in PDF, will point to the start of that following element. In the above example, to the point before the phrase 'To Sherlock'.

This way of adding index entries in text is very neat in your markdown. The trade-off is that it's possible that, in PDF, the index could refer to the page number on which the paragraph starts, while the concept you intended to index actually appears later in the paragraph on the following page. Generally speaking, this trade-off will be worth it.

However, if you absolutely must have the page number exactly right, then you can add your HTML comment inline, like this:

``` md
To Sherlock Holmes <!--index: Adler, Irene --> she is always THE woman. I have seldom heard him mention her under any other name.
```

### How to create the index list

Then in the markdown file for the index itself, you create a list of entries, using exactly the phrases you used when tagging concepts in HTML comments. You do not need to add any links. E.g.:

``` md
- Adler, Irene
- Holmes, Sherlock
{:.reference-index}
```

Then, when you use the output script, choose the 'refresh indexes' option for each output format you're publishing. The script will populate your index list with links.

When you then generate an ouput (e.g. a website or PDF), your book index will include links and/or page numbers, depending on the output format.

> ### Technical explanation
>
> To generate the dynamic 'page' references in a book index, we relay on a number of processing steps and scripts. These are a bit different, depending on the format we're generating. Broadly speaking, these are the steps:
>
> 1. A person must create a list of index entries. See the 'Dynamic indexes' section of the Samples book for an example. We think of each entry as a term that references a concept in the book. Let's call them 'concept terms'.
> 2. A person must note in the book's content where each concept appears, using HTML comments that begin with `index:`. Where a single comment includes more than one concept term, each term should be on its own line. This is described in the guidance above.
> 3. We use the concept terms in the book to generate a 'database' of concept terms. This is generated from the 'Refresh book index' option in the output script, which builds the book HTML and then uses Puppeteer (launched by `render-book-index.js`) to scrape the content, looking for `index:` comments. This generates a file for each book output, which contains a Javascript object containing all the concept terms (e.g. `book-index-print-pdf.js`) as a kind of concept 'database'. This is a similar process to that used to generate a search index for web and app outputs. The 'database' (we're avoiding using the word 'index' to avoid confusion) is loaded on each page as part of the `bundle.js` script.
> 4. Next, we need to turn the HTML comments into anchor targets that we can link to. And we need to add links (clickable 'page' references) to each concept term in the book index. That is done in two different ways, depending on the output format:
>    - For web and app output, we use client-side Javascript. The `index-targets.js` script finds all the `index:` comments on the page and creates `<a>` tags. And the `index-lists.js` script looks for `.reference-index` lists, and when it finds one, compares each item on the list with the concept terms in the `book-index-*.js` 'database'. When a concept term matches an entry in the database, it inserts a link to the relevant anchor-tag ID after the concept term.
>    - For PDF and epub outputs, we can't use client-side Javascript. PrinceXML doesn't support some of the comment-handling required. And in epub, internal links that are dynamically generated client-side are not clickable for security reasons. So, for these outputs, we pre-process the HTML. After the output script runs Jekyll to build the HTML in `_site`, it processes each file in the book with gulp tasks. These tasks create anchor-tag targets in the book content from `index:` HTML comments, and populate the `.reference-index` with links. These tasks are logical equivalents of the client-side scripts mentioned for web and app above.
> 5. In PDF output, we use Prince functions in CSS to generate page references. These Prince functions not only create the page ranges (e.g. '23â€“25') but also avoid adding duplicate page references. This is because, if a concept term appears twice on the same page, there will be two links pointing to that page, and we want only one instance of that page number to show in the book index.
{:.box}

## The legacy, manual method

### How to tag indexed phrases

To tag a phrase in the text, we make it a link, and we give that link:

* a target that points to the index
* a class (`.indexed`) to control what it looks like
* an ID (e.g. `#democracy-1`) to uniquely identify it.

The link target should point to the index entry for that word. This way, clicking the word in the text will take you to the right place in the index. And clicking the page reference in the index will take you to the word in the text.

Here's an example of the link in the text:

~~~
Late that night, [Bob](reference-index.html#bob-1){:.indexed #bob-1} realised the key was in his pocket.
~~~

And then when Bob appears later in the book: 

~~~
Eventually, [Bob](reference-index.html#bob-2){:.indexed #bob-2} called her to confess.
~~~

Note that the ID must be unique for every instance of Bob.

### How to create the index list

Then in the index itself, you create a list of entries. After each entry, you add links to each instance of that entry you've tagged in the text. And you give each link the ID that you've pointed to in your tagged word's link target.

> Tech tip: To make it easy for us to manage, we use the same ID for the tagged word and the index entry. You don't have to us the same ID. For instance, your tagged-word's ID might be `#text-bob-1` and your index entry's link `#index-bob-1`. If like us you use the same ID in both cases, remember that your index must be in a separate file from your text, since IDs must be unique within each file.

Here is what your markdown for the index might look like. Here we've included examples of sub-entries, and the tag to use for the entire list to style it as an index: `{:.reference-index}`.

~~~
* Alice
[1](1.html#alice-1){:#alice-1}
[2](3.html#alice-2){:#alice-2}
* Bob
[1](1.html#bob-1)
[2](9.html#bob-2)
* key
[1](4.html#key-1)
    - private
    [1](4.html#key-private-1)
    - public
    [1](4.html#key-public-1)
{:.reference-index}
~~~

In this example, we've used numbers as the link text. On screen, these will stay numbers, e.g.:

Alice 1, 2

The stylesheet will add the commas between entries (so you could globally replace with semicolons or otherwise). In print output (using PrinceXML), the stylesheet will replace those numbers with page references.
